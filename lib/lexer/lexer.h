#ifndef LEXER_H
#define LEXER_H

#include <stddef.h>

typedef enum {
// GENERATE BEGIN TYPE {{{
	TOK_WORD_IF,
	TOK_WORD_ELSE,
	TOK_WORD_ELIF,
	TOK_WORD_WHILE,
	TOK_WORD_FOR,
	TOK_WORD_DO,
	TOK_WORD_IN,
	TOK_WORD_TO,
	TOK_WORD_BREAK,
	TOK_WORD_CONTINUE,
	TOK_WORD_MATCH,
	TOK_WORD_WHEN,
	TOK_WORD_SWITCH,
	TOK_WORD_CASE,
	TOK_WORD_DEFAULT,
	TOK_WORD_IMMUT,
	TOK_WORD_TYPE,
	TOK_WORD_ALIAS,
	TOK_WORD_RECORD,
	TOK_WORD_UNION,
	TOK_WORD_FN,
	TOK_WORD_IMPORT,
	TOK_WORD_AS,
	TOK_WORD_FROM,
	TOK_WORD_AND,
	TOK_WORD_OR,
	TOK_WORD_XOR,
	TOK_WORD_NOT,
	TOK_PRIM_UINT,
	TOK_PRIM_U8,
	TOK_PRIM_U16,
	TOK_PRIM_U32,
	TOK_PRIM_U64,
	TOK_PRIM_INT,
	TOK_PRIM_I8,
	TOK_PRIM_I16,
	TOK_PRIM_I32,
	TOK_PRIM_I64,
	TOK_PRIM_USIZE,
	TOK_PRIM_ISIZE,
	TOK_PRIM_F32,
	TOK_PRIM_F64,
	TOK_PRIM_FLOAT,
	TOK_PRIM_BOOL,
	TOK_LIT_TRUE,
	TOK_LIT_FALSE,
	TOK_IDENT,
	TOK_LIT_INT_DEC,
	TOK_LIT_INT_HEX,
	TOK_LIT_INT_OCT,
	TOK_LIT_INT_BIN,
	TOK_LIT_FLOAT,
	TOK_LIT_CHAR,
	TOK_LIT_STR,
	TOK_LIT_STR_RAW,
	TOK_ERR,
	TOK_EOF,
	TOK_PAREN_L,
	TOK_PAREN_R,
	TOK_BRACKET_L,
	TOK_BRACKET_R,
	TOK_BRACE_L,
	TOK_BRACE_R,
	TOK_DOT,
	TOK_COMMA,
	TOK_SEMICOLON,
	TOK_COLON,
	TOK_EQUALS,
	TOK_VERT_LINE,
	TOK_AMPERSAND,
	TOK_TILDE,
	TOK_BANG,
	TOK_QUESTION,
	TOK_CARET,
	TOK_MINUS,
	TOK_PLUS,
	TOK_STAR,
	TOK_SLASH,
	TOK_PERCENT,
	TOK_LESS,
	TOK_GREATER,
	TOK_COMP_EQ,
	TOK_COMP_NE,
	TOK_COMP_LE,
	TOK_COMP_GE,
	TOK_ADD_ASSIGN,
	TOK_SUB_ASSIGN,
	TOK_MUL_ASSIGN,
	TOK_DIV_ASSIGN,
	TOK_MOD_ASSIGN,
	TOK_ARROW,
	TOK_RETURN_ARROW,
	TOK_FWD_COMPOSE,
	TOK_RANGE,
	TOK_MODULE,
	TOK_CONCAT,
	TOK_BIT_LSL,
	TOK_BIT_LSR,
	TOK_BIT_ASL,
	TOK_BIT_ASR,
	TOK_BIT_AND,
	TOK_BIT_OR,
	TOK_BIT_XOR,
// GENERATE END TYPE }}}
} TokenType;

typedef struct {
	TokenType type;
	char* value;
} Token;

Token make_token(TokenType type, const char* value);
Token* lex(const char* input);
void free_tokens(Token* tokens);

#endif
