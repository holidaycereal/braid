vim:expandtab
# bnf grammar for my programming language, braid
# --
# this grammar is very incomplete, and inaccurate in some places.
# for example, i don't properly encode rules about trailing commas.
# this file is just here for documentation, to give you a general idea.

<program> ::= <top-level>* <main-fn>

<main-fn> ::= <fn-def>

<top-level> ::=
    <const-def>
  | <fn-def>
  | <type-def>
  | <union-def>
  | <record-def>
  | <trait-def>
  | <impl-def>

<const-def> ::= 'const' <ident> '=' <expr> ';'
<fn-def> ::= 'fn' <ident> <fn-params> [<fn-type-sig>] <fn-body>
<type-def> ::= 'type' <ident> [<type-params>] '=' <type-expr> ';'
<union-def> ::= 'union' <ident> [<type-params>] '{' (<variant> ',')+ '}'
<record-def> ::= 'record' <ident> [<type-params>] '{' (<field> ',')+ '}'
<trait-def> ::=
    'trait' <ident> [<type-params>] <ident> [<type-params>]
    '{' (<ident> <fn-params> [<fn-type-sig>] ';')+ '}'
<impl-def> ::= 'impl' <trait> <type-expr> '{' <fn-def>+ '}'

<fn-params> ::= ('(' <ident-list> ')')+
<fn-type-sig> ::= ':' <type-expr> '->' (<type-expr> | <fn-type-sig>)
<fn-body> ::= '=' <expr> ';' | 'proc' <statement>* 'end'
<type-params> ::= '[' <ident-list> ']'
<variant> ::= <ident> | <constructor> | <record-variant>
<field> ::= <ident> ':' <type-expr> | <union-field>

<expr> ::=
    <unit>
  | <ident>
  | <literal>
  | <list>
  | <tuple>
  | <match>
  | <record>
  | <ternary>
  | <bin-op-app>
  | <un-op-app>
  | <fn-app>
  | <lambda>

<literal> ::= <int> | <float> | <bool> | <char>
<list> ::= '[' (<expr> ',')* ']' | <string>
<tuple> ::= '(' (<expr> ',')* ')'
<match> ::= 'match' <expr> '{' (<pattern> '->' <expr> ',')+
<record> ::= [<ident>] '{' (<ident> '=' <expr> ',')+ '}'
<ternary> ::= 'if' <condition> 'then' <expr> 'else' <expr>
<bin-op-app> ::= <expr> <bin-op> <expr>
<un-op-app> ::= <un-op> <expr>
<fn-app> ::= <normal-fn-app> | <infix-fn-app> | <fwd-composed-fn-app>
<lambda> ::= 'fn' (<ident> | '(' <ident-list> ')') '->' <expr>

<bin-op> ::=
    '::' | '.'
  | '*'  | '/' | '%'
  | '+'  | '-'
  | '++' | '..' | '.*'
  | '<'  | '>' | '<=' | '>=' | '==' | '!='
  | 'and' | 'xor' | 'or'
<un-op> ::= '-' | 'not' | '&' | '#'

<normal-fn-app> ::= <ident> <tuple>+
<infix-fn-app> ::= <expr> '|' (<normal-fn-app> | <ident>) '|' <expr>
<fwd-composed-fn-app> ::= <expr> '>>' <normal-fn-app>

<pattern> ::=
    <const-expr>
  | <ident>
  | <constructor-pattern>
  | <pattern> '|' <pattern>

<type-expr> ::=
    <ident>
  | <tuple-type>
  | <constructor-app>

<tuple-type> ::= '(' (<type-expr> ',')* ')'
<constructor-app> ::= <ident> '[' (<type-expr> ',')+ ']'

<statement> ::=
    <declaration>
  | <assignment>
  | <fn-call>
  | <return>
  | 'continue;'
  | 'break;'
  | <while-loop>
  | <for-loop>
  | <if-block>
  | <case-block>

<declaration> ::= 'let' <ident> [':' <type-expr>] ['=' <expr>] ';'
<assignment> ::= <ident> '=' <expr> ';'
<fn-call> ::= <fn-app> ';'
<return> ::= '=>' <expr> ';'
<while-loop> ::=
    'while' <condition> 'do'
    <statement>*
    'done'
<for-loop> ::=
    'for' (<ident> | '(' <ident-list> ')') 'in' <iterator> 'do'
    <statement>*
    'done'
<if-block> ::=
    'if' <condition> 'then' <statement>*
    ('elif' <condition> 'then' <statement>*)*
    ['else' <statement>*]
    'end'
<case-block> ::=
    'case' <expr> 'of'
    (<pattern> ':' <statement>*)*
    ['else' <statement>*]
    'end'
