vim:expandtab

<program> ::= <top-level>* <main-fn>
<main-fn> ::= <fn-def>
<top-level> ::=
    <decl>
  | <alias-def>
  | <type-def>
  | <record-def>
  | <union-def>
  | <fn-def>
  | <import>

<decl>       ::= <var_decl> | <immut>
<var_decl>   ::=         <ident> ":" [<type>] ["=" <expr>] ";"
<immut-decl> ::= "immut" <ident> ":" [<type>] ["=" <expr>] ";"

<alias-def> ::= "alias" <ident> ["(" <ident-list> ")"] "=" <expr> ";"
<type-def>  ::= "type" <ident> "=" <type> ";"

alias vec_add(a, b) = (a.x + b.x, a.y + b.y);

<record-def> ::= "record" <ident> <record-body>
<union-def>  ::= "union"  <ident> <union-body>

<union-body>  ::= "{" ["|"] <variant> ("|" <variant>)* "}"
<record-body> ::= "{" ["^"] <field>   ("^" <field>)*   "}"

<field> ::=
    <ident> ":" <type> ["=" <expr>]
  | <ident> <record-body>
  | <ident> <union-body>
<variant> ::=
    <ident>
  | <ident> "(" <type> ")")
  | <ident> <record-body>

<fn-def> ::=
    "fn" <ident>
    ("(" <ident>* ")")+
    [":" (<type> "->")+ <type>]
    ("{" <stmt>* "}" | <return-stmt> ";")

<import> ::= "import" (<ident> ["as" <ident>] | <ident>+ from <ident>) ";"

<stmt> ::=
    <decl>
  | <assign>
  | <fn-call>
  | <return>
  | <break>
  | <continue>
  | <if-block>
  | <switch-block>
  | <while-block>
  | <for-in-block>
  | <for-to-block>

<assign>   ::= <ident> "=" <expr>        ";"
<fn-call>  ::= <ident> ("(" <expr> ")")+ ";"
<return>   ::= "=>" <expr>               ";"
<break>    ::= "break" <num-scopes>      ";"
<continue> ::= "continue"                ";"
<if-block> ::=
    "if"     <expr> "{" <stmt>* "}"
    ("elif"  <expr> "{" <stmt>* "}")*
    ["else"         "{" <stmt>* "}"]
<switch-block> ::=
    "switch" <expr> "{"
    ("case" <expr> ("|" <expr>)* ":" <stmt>*)*
    ["default"                   ":" <stmt>*]
    "}"
<while-block>  ::=
    "while" <expr> ["," <stmt>]
    "{" <stmt>* "}"
<for-in-block> ::=
    "for" <ident> "in" <expr>
    "{" <stmt>* "}"
<for-to-block> ::=
    "for" (<assign> | decl) "to" <expr> ["," <stmt>]
    "{" <stmt>* "}"

<type> ::=
    <primitive>
  | <generic>
  | <tuple-type>
  | <array-type>
  | <functor-app>
  | <type-alias-ref>
  | <record-ref>
  | <union-ref>
  | <inferred>

<primitive>      ::= (uint-type) | (int-type) | (float-type) | (bool-type)
<generic>        ::= <ident>
<tuple-type>     ::= "(" [<type>] ("," <type>)* ")"
<array-type>     ::= "[" <type> "]"
<functor-app>    ::= <ident> "[" <type> "]"
<type-alias-ref> ::= <ident>
<record-ref>     ::= <ident>
<union-ref>      ::= <ident>
<inferred>       ::= ()

<expr> ::=
    <literal>
  | <alias-ref>
  | <var-ref>
  | <tuple>
  | <list>
  | <record>
  | <match>
  | <ternary>
  | <unary-op-app>
  | <binary-op-app>
  | <fn-app>
  | <lambda>

<literal>   ::= ([0-9]+) | ([0-9]+\.[0.9]+) | "\"" (*)* "\"" | "'" (*) "'"
<alias-ref> ::= <ident>
<var-ref>   ::= <ident>
<tuple>     ::= "(" [<expr>] ("," <expr>)* ")"
<list>      ::= "[" [<expr>] ("," <expr>)* "]"
<record>    ::=
    [<ident>] "{"
    ["^"] <ident> "=" <expr>
    ("^"  <ident> "=" <expr>)*
    "}"
<match>     ::=
    "match" <expr> "{"
    ["|"] <expr> "->" <expr>
    ("|"  <expr> "->" <expr>)*
    "}"
<ternary>       ::= "when" <expr> "->" <expr> "|" <expr>
<unary-op-app>  ::= <unary-op> <expr>
<binary-op-app> ::= <expr> <binary-op> <expr>
<fn-app>        ::= <ident> ("(" <expr> ")")*
<lambda>        ::= "(" <ident-list> ")" "=>" <expr>

<unary-op>  ::= "~" | "!" | "&"
<binary-op> ::=
    ".<" | ".>" | ":<" | ":>"
  | ".*" | ".+" | ".^"
  | "and" | "or" | "xor"
  | "==" | "!=" | "<=" | ">=" | "<" | ">"
  | "+"  | "-"  | "*"  | "/"  | "%"
  | "."  | "[]" | "++" | ".."

<ident> ::= ([_a-zA-Z][_a-zA-Z0-9]+)
<ident-list> ::= <ident> ("," <ident>)*
