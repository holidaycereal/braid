<program> ::= <top-level>* <main-fn>
<main-fn> ::= "fn" "main" <fn-body>
<top-level> ::=
    <alias-def>
  | <type-def>
  | <record-def>
  | <union-def>
  | <fn-def>
  | <import>

<alias-def> ::= "alias" <ident> ["(" <ident-list> ")"] "=" <expr> ";"
<type-def>  ::= "type"  <ident> "=" <type> ";"

<record-def>  ::= "record" <ident> <record-body>
<union-def>   ::= "union"  <ident> <union-body>
<record-body> ::=
    ["[" <ident-list> "]"]
    "{" ["^"] <field>   ("^" <field>)*   "}"
<union-body>  ::=
    ["[" <ident-list> "]"]
    "{" ["|"] <variant> ("|" <variant>)* "}"
<field> ::=
    <ident> ":" <type> ["=" <expr>]
  | <ident> <record-body>
  | <ident> <union-body>
<variant> ::=
    <ident>
  | <ident> "(" <type> ")")
  | <ident> <record-body>

<fn-def>  ::= "fn" <ident> <fn-body>
<fn-body> ::=
    ("(" <ident-list> ")")+
    [":" (<type> "->")+ <type> | "->" (<type> "->")* <type>]
    ("{" <stmt>* "}" | <return> ";")

<import> ::= "import" (<ident> ["as" <ident>] | <ident>+ "from" <ident>) ";"

<stmt> ::=
    <mut-decl>
  | <immut-decl>
  | <assign>
  | <fn-call>
  | <return>
  | <break>
  | <continue>
  | <if-block>
  | <switch-block>
  | <while-block>
  | <for-in-block>
  | <for-to-block>

<mut-decl>   ::=         <ident> ":" <type> ["=" <expr>] ";"
<immut-decl> ::= "immut" <ident> ":" <type> "=" <expr> ";"
<assign>     ::= <ident> "=" <expr>        ";"
<fn-call>    ::= <ident> ("(" <expr> ")")+ ";"
<return>     ::= "=>" <expr>               ";"
<break>      ::= "break" <num-scopes>      ";"
<continue>   ::= "continue"                ";"
<if-block>   ::=
    "if"    <expr> ("," <stmt> | "{" <stmt>* "}")
    ("elif" <expr> ("," <stmt> | "{" <stmt>* "}"))*
    ["else"        ("," <stmt> | "{" <stmt>* "}")]
<switch-block> ::=
    "switch" <expr> "{"
    ("case" <expr> ("|" <expr>)* ":" <stmt>*)*
    ["default"                   ":" <stmt>*]
    "}"
<while-block> ::=
    "while" <expr>
    ("," <stmt> | ["," <stmt>] "{" <stmt>* "}")
<for-in-block> ::=
    "for" <ident> "in" <expr>
    ("," <stmt> | "{" <stmt>* "}")
<for-to-block> ::=
    "for" (<assign> | decl) "to" <expr> ["," <stmt>]
    ("," <stmt> | "{" <stmt>* "}")

<type> ::=
    <primitive>
  | <generic>
  | <tuple-type>
  | <array-type>
  | <functor-app>
  | <type-alias-ref>
  | <record-ref>
  | <union-ref>
  | <inferred>

<primitive>      ::= (uint-type) | (int-type) | (float-type) | (bool-type)
<generic>        ::= <ident>
<tuple-type>     ::= "(" [<type>] ("," <type>)* ")"
<array-type>     ::= "[" <type> "]"
<functor-app>    ::= <ident> "[" <type> "]"
<type-alias-ref> ::= <ident>
<record-ref>     ::= <ident>
<union-ref>      ::= <ident>
<inferred>       ::= ()

<expr> ::=
    <value-literal>
  | <alias-ref>
  | <var-ref>
  | <tuple-literal>
  | <list-literal>
  | <record-literal>
  | <match>
  | <ternary>
  | <unary-op-app>
  | <binary-op-app>
  | <fn-app>
  | <lambda>

<value_literal>  ::= ([0-9]+) | ([0-9]+\.[0.9]+) | "'" (*) "'"
<alias-ref>      ::= <ident>
<var-ref>        ::= <ident>
<tuple-literal>  ::= "(" [<expr>] ("," <expr>)* ")"
<list-literal>   ::= "[" [<expr>] ("," <expr>)* "]" | "\"" (*)* "\""
<record-literal> ::=
    [<ident>] "{"
    ["^"] <ident> "=" <expr>
    ("^"  <ident> "=" <expr>)*
    "}"
<match> ::=
    "match" <expr> "{"
    ["|"] <expr> "->" <expr>
    ("|"  <expr> "->" <expr>)*
    "}"
<ternary>       ::= "when" <expr> "->" <expr> "|" <expr>
<unary-op-app>  ::= <unary-op> <expr>
<binary-op-app> ::= <expr> <binary-op> <expr>
<fn-app>        ::= <ident> ("(" <expr> ")")*
<lambda>        ::= "(" <ident-list> ")" "=>" <expr>

<unary-op>  ::= "~" | "!" | "&"
<binary-op> ::=
    ".<" | ".>" | ":<" | ":>"
  | ".*" | ".+" | ".^"
  | "and" | "or" | "xor"
  | "==" | "!=" | "<=" | ">=" | "<" | ">"
  | "+"  | "-"  | "*"  | "/"  | "%"
  | "."  | "[]" | "++" | ".."

<ident> ::= ([_a-zA-Z][_a-zA-Z0-9]+)
<ident-list> ::= <ident> ("," <ident>)*

vim:expandtab
